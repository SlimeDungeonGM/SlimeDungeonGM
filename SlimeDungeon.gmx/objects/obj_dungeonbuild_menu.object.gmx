<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-11</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// @description setup build menu
// You can write your code in this editor
/// initialize build
isbuild = false;

//array_create()

isboundbox = false;
issnap = true;
sizegrid = 32;
objectissnap = false;
objectobjtype = VOID;
objectisfixed = false;

selectobject = -1;
placeobject = noone;

//build options
list_count = 0;
list_index = 0;
list_max = 5;
iscollide = false;

istile = true;
isobject = false;

pickobject = noone;//pick object in the room
pickid = -1;

slotlist = noone;// ds_grid_create(0,4);

//display name

tileblock[0, 0] = "Wall";
tileblock[0, 1] = spr_wall;
tileblock[0, 2] = obj_wall;
tileblock[0, 3] = obj_wall;

tileblock[1, 0] = "Floor";
tileblock[1, 1] = spr_floor;
tileblock[1, 2] = obj_floor;
tileblock[1, 3] = obj_floor;

tileblock[2, 0] = "Dirt";
tileblock[2, 1] = spr_dirt;
tileblock[2, 2] = obj_dirt;
tileblock[2, 3] = obj_dirt;

tileblock[3, 0] = "Rock";
tileblock[3, 1] = spr_rock;
tileblock[3, 2] = obj_rock;
tileblock[3, 3] = obj_rock;

tileblock[4, 0] = "Sand";
tileblock[4, 1] = spr_sand;
tileblock[4, 2] = obj_sand;
tileblock[4, 3] = obj_sand;

tileblock[5, 0] = "Water";
tileblock[5, 1] = spr_water;
tileblock[5, 2] = obj_water;
tileblock[5, 3] = obj_water;

tileblock[6, 0] = "Lava";
tileblock[6, 1] = spr_lava;
tileblock[6, 2] = obj_lava;
tileblock[6, 3] = obj_lava;

traps[0,0] = "Box";
traps[0,1] = spr_box;
traps[0,2] = obj_box;
traps[0,3] = obj_box;

traps[1,0] = "Spike";
traps[1,1] = spr_spike;
traps[1,2] = obj_spike;
traps[1,3] = obj_spike;

tools[0,0] = "Spike";
tools[0,1] = spr_spike;
tools[0,2] = obj_spike;
tools[0,3] = obj_spike;

items[0,0] = "Spike";
items[0,1] = spr_spike;
items[0,2] = obj_spike;
items[0,3] = obj_spike;

creatures[0,0] = "Slime"
creatures[0,1] = spr_slime
creatures[0,2] = obj_slime
creatures[0,3] = obj_slime

creatures[1,0] = "Slime Spawner"
creatures[1,1] = spr_spawner
creatures[1,2] = obj_spawner
creatures[1,3] = obj_slime

slotlist = tileblock;


buttontabs[0] = instance_create(0,0,obj_button);
buttontabs[0].name = "Blocks";
buttontabs[0].width = 144;
buttontabs[0].brender = false;
buttontabs[0].scriptfile = scr_buildtab_select;
buttontabs[0].arg = 0;

buttontabs[1] = instance_create(0,0,obj_button);
buttontabs[1].name = "Traps";
buttontabs[1].width = 144;
buttontabs[1].brender = false;
buttontabs[1].scriptfile = scr_buildtab_select;
buttontabs[1].arg = 1;

buttontabs[2] = instance_create(0,0,obj_button);
buttontabs[2].name = "Tools";
buttontabs[2].width = 144;
buttontabs[2].brender = false;
buttontabs[2].scriptfile = scr_buildtab_select;
buttontabs[2].arg = 2;

buttontabs[3] = instance_create(0,0,obj_button);
buttontabs[3].name = "Items";
buttontabs[3].width = 144;
buttontabs[3].brender = false;
buttontabs[3].scriptfile = scr_buildtab_select;
buttontabs[3].arg = 3;

buttontabs[4] = instance_create(0,0,obj_button);
buttontabs[4].name = "Creaures";
buttontabs[4].width = 144;
buttontabs[4].brender = false;
buttontabs[4].scriptfile = scr_buildtab_select;
buttontabs[4].arg = 4;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///delay
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// select and build mouse click

if (global._ishud)
{
    ///build menu
    if(isbuild){
        //show_debug_message("building...");
        isboundbox = false;
        iscollide = false;
        var xx = display_get_gui_width()/2;
        var yy = display_get_gui_height()/2;
        var screenx = device_mouse_x_to_gui(0);
        var screeny = device_mouse_y_to_gui(0);
        var id_name = "none";
            
        if(pickid != -1){    
            with(pickid){//object id
                id_name = name;
            }
            if(keyboard_check(vk_delete)){
                with(pickid){
                    instance_destroy();
                }
                pickid = -1;
                //show_debug_message("delete object");
            }
        }
        
        for (var i = 0; i &lt; array_length_1d(buttontabs); i++){
            buttontabs[i].x = xx+(i*150)-256-128;
            buttontabs[i].y = 64;
            buttontabs[i].brender = true;
        }

        //draw text h menu
        /*
        for (var i = 0; i &lt; array_length_1d(buildmenu); i++)
        {
            if( (xx+(64*i)+(-16)-112 &lt; screenx ) and screenx &lt; (xx+(64*i)+(+28)-112) and ((32)*2) &lt; screeny and screeny &lt; ((32)*3) ){
                isboundbox = true;
                if(mouse_check_button(mb_left)){
                    //show_debug_message(string(buildmenu[i]));
                    if(buildmenu[i] == "Blocks"){
                        slotlist = tileblock;
                    }
                    if(buildmenu[i] == "Traps"){
                        slotlist = traps;
                    }
                    if(buildmenu[i] == "Creaures"){
                        slotlist = creatures;
                    }
                }
            }
        }
        */
    
        //check if icon are bound here min and max
        //if(screeny &gt; (4 + yy -64) and screeny &lt; (5*(32+4) + yy -64)){//size and offsets and items
        //if(screenx &gt; 4 and screenx &lt; (32+4) and screeny &gt; 4 and screeny &lt; (5*(32+4))){//size and offsets
        //bottom left
        if(screenx &gt; 4 and screenx &lt; (32+4) and screeny &gt; (4 + yy -64) and screeny &lt; (5*(32+4) + yy -64)){
            //show_debug_message("in bound?");
            isboundbox = true;
            //need to add icon select here to build the dungeon
        }else{
            //show_debug_message("out bound?");   
        }
        
        //clear title or object
        if(screenx &gt; 4 and screenx &lt; (32+4) and screeny &gt; (yy - ((32+4)*4)) and screeny &lt; (yy - (32*3))){    
            //show_debug_message("in bound?");
            if(mouse_check_button(mb_left) == true and alarm[0] &lt;= 0){
                if(selectobject != -1){
                    //selectobject.visible = false;
                    selectobject = -1;
                }
                alarm[0] = room_speed/6;
            }
            isboundbox = true;
        }else{
            //show_debug_message("out bound?");
        }
        
        if(screenx &gt; 4 and screenx &lt; (32+4) and screeny &gt; (yy - ((32+4)*3)) and screeny &lt; (yy - (32*2))){    
            //show_debug_message("in bound?");
            if(mouse_check_button(mb_left) == true and alarm[0] &lt;= 0){
                list_index--;
                alarm[0] = room_speed/6;
            }
            isboundbox = true;
        }else{
            //show_debug_message("out bound?");
        }
        //draw up button
        
        if(screenx &gt; 4 and screenx &lt; (32+4) and screeny &gt; (yy + ((32+4)*(3))) and screeny &lt; (yy + (32*(5)))){    
            //show_debug_message("in bound?");
            if(mouse_check_button(mb_left) == true and alarm[0] &lt;= 0){
                list_index++;
                alarm[0] = room_speed/6;
            }
            isboundbox = true;
        }else{
            //show_debug_message("out bound?");
        }
        //draw down button  
        
        if(screenx &gt; 4 and screenx &lt; (32+4) and screeny &gt; (display_get_gui_height()-32) and screeny &lt; (display_get_gui_height())){    
            //show_debug_message("in bound?");
            if(mouse_check_button(mb_left) == true and alarm[0] &lt;= 0){
                if(issnap){
                    issnap = false;
                }else{
                    issnap = true;
                }
                alarm[0] = room_speed/6;
                //show_debug_message("snap?");
            }
            isboundbox = true;
        }else{
            //show_debug_message("out bound?");
        }
        
        
        // draw icons
        list_count = 0;
        if(list_index &lt;= 0){
            list_index = 0;
        }
        //check if array list max list to not move
        if(array_height_2d(slotlist) &lt;= list_max){
            list_index = 0;
        }else{
            if(list_index &gt; array_height_2d(slotlist) - list_max){
                list_index = array_height_2d(slotlist) - list_max;
            }
        }
        //draw iamge and check if mouse is press left
        for (i = list_index; i &lt; array_height_2d(slotlist); i++){    
            if(list_count &gt;= list_max){
                break;
            }
            if(screenx &gt; 4 and screenx &lt; (32+4) and screeny &gt; (yy - 64 + (32+4)*list_count) and screeny &lt; (yy - 32 + (32+4)*list_count)){    
                if(mouse_check_button(mb_left) == true and alarm[0] &lt;= 0){
                    //show_debug_message(string(slotlist[i,0]));
                    //check if select exist destory
                    if(selectobject == -1){
                    }else{
                        selectedobject = -1;
                    }
                    
                    //create object
                    selectobject = i;
                    show_debug_message( string(i) );
                    
                    var placeholder = instance_create(-100,-100, slotlist[ i, 2]);
                    
                    show_debug_message( string(placeholder) );
                    //set variables holder item
                    objectissnap = placeholder.issnap;
                    objectobjtype = placeholder.objtype;
                    objectisfixed = placeholder.isfixed;
                    with (placeholder)
                    {
                        instance_destroy();
                    }
                    //selectobject.visible = true;
                    placeobject = slotlist[ i, 2];
                    alarm[0] = room_speed/6;
                }
            }
            list_count++;
        }
        //var xx_p = yy - 64 + 32*0;//top
        //var xx_p = yy - 32 + 32*0;//bottom
        //draw_sprite(spr_up,0,64,xx_p);  
        //if(screenx &gt; 4 and screenx &lt; (32+4) and screeny &gt; (yy - 64 + (32+4)*4) and screeny &lt; (yy - 32 + (32+4)*4)){    
            //show_debug_message("in bound?");
        //}else{
            //show_debug_message("out bound?");
        //}
        
    
        //if(place_empty(mouse_x, mouse_y)){
            //show_debug_message("Hit something");
        //}else{
            //show_debug_message("miss");
        //}
        
        //if(place_meeting(mouse_x, mouse_y, obj_wall)){
            //show_debug_message("Hit something");
        //}else{
            //show_debug_message("notthing");
        //}
        
        //show_debug_message(string(mouse_x)+":"+string(mouse_x));
        //place object
        if(mouse_check_button_pressed(mb_left) == true and isboundbox = false ){
            if(placeobject != noone and selectobject != -1){
                //if(!selectobject.iscollision){
                var gx = mouse_x div sizegrid;
                var gy = mouse_y div sizegrid;
                show_debug_message("place....");
                //var obj_instant;
                
                if (objectobjtype == WALL)
                {
                    
                    var wall = instance_position((gx*sizegrid)+(sizegrid/2),(gy*sizegrid)+(sizegrid/2), obj_wall);
                    var flooring = instance_position((gx*sizegrid)+(sizegrid/2),(gy*sizegrid)+(sizegrid/2), obj_flooring);
                    
                    if (wall == noone &amp;&amp; flooring != noone)
                    {
                        instance_create(gx*CELL_WIDTH, gy*CELL_HEIGHT, placeobject);
                    }
                    show_debug_message("Type WALL");
                }
                else if (objectobjtype == FLOOR)
                {
                    
                    var flooring = instance_position((gx*sizegrid)+(sizegrid/2),(gy*sizegrid)+(sizegrid/2), obj_flooring);
                    
                    if (flooring != noone)
                    {
                        while (flooring != noone)
                        {
                            with (flooring)
                            {
                                instance_destroy();
                            }
                            flooring = instance_position((gx*sizegrid)+(sizegrid/2),(gy*sizegrid)+(sizegrid/2), obj_flooring);
                        }
                        instance_create(gx*CELL_WIDTH, gy*CELL_HEIGHT, placeobject);
                    }
                    show_debug_message("Type FLOOR");
                }
                else if (objectobjtype == VOID)
                {
                    
                    var flooring = instance_position((gx*sizegrid)+(sizegrid/2),(gy*sizegrid)+(sizegrid/2), obj_flooring);
                    
                    if (flooring != noone)
                    {   
                        var xplace = mouse_x;
                        var yplace = mouse_y;
                        if (objectissnap)
                        {
                            xplace = gx*CELL_WIDTH;
                            yplace = gy*CELL_HEIGHT;
                        }
                        
                        var createdObj = instance_create(xplace, yplace, placeobject);
                        if (createdObj.object_index == obj_spawner)
                        {
                            createdObj.monster_summon =  slotlist[ selectobject, 3];
                        }
                    }
                    show_debug_message("Type VOID");
                }
                
                
                
                    //once place check conditions
                    //check object instance for store and get objects
                    if(instance_exists(obj_level_generate_dungeon))
                    {
                        var gx = mouse_x div sizegrid;
                        var gy = mouse_y div sizegrid;
                        if(objectobjtype == WALL || objectobjtype == FLOOR){
                            //check and assign type of dungeon floor or wall                
                            if(objectobjtype == WALL){
                                //block path
                                mp_grid_add_cell(obj_level_generate_dungeon.grid_path,gx,gy);
                                obj_level_generate_dungeon.grid[# gx,gy] = WALL;
                            }
                            if(objectobjtype == FLOOR){
                                //clear path
                                mp_grid_clear_cell(obj_level_generate_dungeon.grid_path,gx,gy);
                                obj_level_generate_dungeon.grid[# gx,gy] = FLOOR;
                            }
                            //check if object exist on the grid
                            if(obj_level_generate_dungeon.grid_tileobjects[# gx,gy] != noone){
                                //get array grid and destory instance object
                                var _obj = obj_level_generate_dungeon.grid_tileobjects[# gx,gy];
                                with(_obj){
                                    instance_destroy();
                                }
                                //assign grid object and create object         
                                obj_level_generate_dungeon.grid_tileobjects[# gx,gy] = instance_create((gx)*32, (gy)*32, placeobject);
                            }
                            else
                            { 
                                obj_level_generate_dungeon.grid_tileobjects[# gx,gy] = instance_create((gx)*32, (gy)*32, placeobject);
                            }
                            //show_debug_message("place tile?");
                        }
                        //check trap grid
                        
                        
                        
                        if(objectobjtype == TRAP){
                            if(obj_level_generate_dungeon.grid_trapobjects[# gx,gy] != noone){
                                var _obj = obj_level_generate_dungeon.grid_trapobjects[# gx,gy];
                                with(_obj){
                                    instance_destroy();
                                }
                            }
                            //show_debug_message("create traps");
                            obj_level_generate_dungeon.grid_trapobjects[# gx,gy] = instance_create((gx)*CELL_WIDTH, (gy)*CELL_HEIGHT, placeobject);
                            //obj_level_generate_dungeon.grid_objectplaces[# gx,gy] = instance_create((gx)*CELL_WIDTH+CELL_WIDTH/2, (gy)*CELL_HEIGHT+CELL_HEIGHT/2, placeobject);
                        }
                        
                        
                        //need to change the code once figure out the design
                        //if(selectobject.objtype == PLACE){
                        if(objectobjtype == PLACE){
                            if(selectobject.iscollision){
                                //show_debug_message("There is collision!");
                            }else{
                                show_debug_message("Place");
                                var itemplace = noone;
                                if(selectobject.isfixed){//try to center
                                    //show_debug_message("isfixed place item?");
                                    if(issnap){//check if neeb fixed from users for cell
                                        itemplace = instance_create(gx*CELL_WIDTH+CELL_WIDTH/2, gy*CELL_HEIGHT+CELL_HEIGHT/2, placeobject);
                                    }else{//used mouse position for place
                                        itemplace = instance_create(mouse_x,mouse_y, placeobject);
                                    }
                                }else if(selectobject.issnap){//snap to grid
                                    //show_debug_message("snap place item?");
                                     itemplace = instance_create(gx*CELL_WIDTH, gy*CELL_HEIGHT, placeobject);
                                }else{//place any where that is not grid or fixed
                                     //add list place is not grid
                                     //show_debug_message("place item?");
                                     itemplace = instance_create(mouse_x, mouse_y, placeobject);
                                }
                                ds_list_add(obj_level_generate_dungeon.dungeonbjects,itemplace);
                            }
                            //show_debug_message(string(array_length_1d(obj_level_generate_dungeon.objectplaces)));
                            var len = ds_list_size(obj_level_generate_dungeon.dungeonbjects);
                            show_debug_message(string(len));
                        }
                        
                    }
                //}else{
                    //show_debug_message("There is collision!");
                //}
                
            }
        }
    }else{
        if(selectobject != -1){
            selectedobject = -1;
        }
        
        for (var i = 0; i &lt; array_length_1d(buttontabs); i++){
            buttontabs[i].brender = false;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(global._ishud){
    //script_execute(scr_dungeon_build_menu);///build menu
    if(isbuild){
        isboundbox = false;
        iscollide = false;
        var xx = display_get_gui_width()/2;
        var yy = display_get_gui_height()/2;
        var screenx = device_mouse_x_to_gui(0);
        var screeny = device_mouse_y_to_gui(0); 
        draw_text(xx,16,"BUILD MODE");
        var id_name = "none";
              
        draw_text(xx,32,"Select: "+id_name);
        draw_set_halign(fa_left);
        /*
        for (var i = 0; i &lt; array_length_1d(buildmenu); i++)
        {
            draw_text(xx+(i*64)-92-32, 64, string( buildmenu[i] ));
        }
        */
        //draw text h menu
    
        //check if icon are bound here min and max
        //if(screeny &gt; (4 + yy -64) and screeny &lt; (5*(32+4) + yy -64)){//size and offsets and items
        //if(screenx &gt; 4 and screenx &lt; (32+4) and screeny &gt; 4 and screeny &lt; (5*(32+4))){//size and offsets
        //bottom left
        if(issnap){
            draw_sprite(spr_grid_on,0,4,display_get_gui_height()-32);
        }else{
            draw_sprite(spr_grid_off,0,4,display_get_gui_height()-32);
        }
        
        //clear title or object
        draw_sprite(spr_clear_obj,0,0,(yy - ((32+4)*4)));
        
        //draw up button
        draw_sprite(spr_up,0,4,yy+((32+4)*-1)-64); 
    
        //draw down button
        draw_sprite(spr_down,0,4,yy+((32+4)*5)-64);     
        
        /*if(screenx &gt; 4 and screenx &lt; (32+4) and screeny &gt; (display_get_gui_height()-32) and screeny &lt; (display_get_gui_height())){    
            //show_debug_message("in bound?");
            if(mouse_check_button(mb_left) == true and alarm[0] &lt;= 0){
                if(issnap){
                    issnap = false;
                    draw_sprite(spr_grid_off,0,4,display_get_gui_height()-32);
                }else{
                    issnap = true;
                    draw_sprite(spr_grid_on,0,4,display_get_gui_height()-32);
                }
                alarm[0] = room_speed/6;
                //show_debug_message("snap?");
            }
            isboundbox = true;
        }else{
            //show_debug_message("out bound?");
        }*/
        
        
        // draw icons
        list_count = 0;
        if(list_index &lt;= 0){
            list_index = 0;
        }
        //check if array list max list to not move
        if(array_height_2d(slotlist) &lt;= list_max){
            list_index = 0;
        }else{
            if(list_index &gt; array_height_2d(slotlist) - list_max){
                list_index = array_height_2d(slotlist) - list_max;
            }
        }
        //draw image and check if mouse is press left
        for (i = list_index; i &lt; array_height_2d(slotlist); i++){    
            if(list_count &gt;= list_max){
                break;
            }
            if(screenx &gt; 4 and screenx &lt; (32+4) and screeny &gt; (yy - 64 + (32+4)*list_count) and screeny &lt; (yy - 32 + (32+4)*list_count)){    
            }
            draw_text(48,yy+((32+4)*list_count)-64,slotlist[ i, 0]);
            if(slotlist[ i, 1] != noone){
                var xOffset = sprite_get_xoffset(slotlist[ i, 1]);
                var yOffset = sprite_get_yoffset(slotlist[ i, 1]);
                draw_sprite(slotlist[ i, 1],0,4+xOffset,yy+((32+4)*list_count)-64+yOffset);
            }else{
                draw_sprite(spr_slot,0,4,yy+((32+4)*list_count)-64);
            }
            list_count++;
        }
        //var xx_p = yy - 64 + 32*0;//top
        //var xx_p = yy - 32 + 32*0;//bottom
        //draw_sprite(spr_up,0,64,xx_p);  
        //if(screenx &gt; 4 and screenx &lt; (32+4) and screeny &gt; (yy - 64 + (32+4)*4) and screeny &lt; (yy - 32 + (32+4)*4)){    
            //show_debug_message("in bound?");
        //}else{
            //show_debug_message("out bound?");
        //}
        
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (global._ishud)
{///build menu
    if(isbuild){
        isboundbox = false;
        iscollide = false;
        var xx = display_get_gui_width()/2;
        var yy = display_get_gui_height()/2;
        var screenx = device_mouse_x_to_gui(0);
        var screeny = device_mouse_y_to_gui(0); 
        //place preview
        if(selectobject != -1){
            //selectobject.visible = true;
            //divide and floor and time
            if(objectissnap){
                draw_sprite(slotlist[ selectobject, 1], 0, 30, 30);
                draw_sprite(slotlist[ selectobject, 1], 0, (mouse_x div CELL_WIDTH)*32 , (mouse_y div CELL_HEIGHT)*32);
                //selectobject.phy_position_x = (mouse_x div CELL_WIDTH)*32;
                //selectobject.phy_position_y = (mouse_y div CELL_HEIGHT)*32;
            }else if(objectisfixed){
                if(issnap){
                    draw_sprite(slotlist[ selectobject, 1], 0, (mouse_x div CELL_WIDTH)*32 + CELL_WIDTH/2, (mouse_y div CELL_HEIGHT)*32 + CELL_HEIGHT/2 );
                    ///selectobject.phy_position_x = (mouse_x div CELL_WIDTH)*32 + CELL_WIDTH/2;
                   // selectobject.phy_position_y = (mouse_y div CELL_HEIGHT)*32 + CELL_HEIGHT/2;
                }else{
                    draw_sprite(slotlist[ selectobject, 1], 0, mouse_x, mouse_y);
                    ////selectobject.phy_position_x = mouse_x;
                   // selectobject.phy_position_y = mouse_y;
                }
            }else{
                draw_sprite(slotlist[ selectobject, 1], 0, mouse_x, mouse_y);
               /// selectobject.phy_position_x = mouse_x;
               // selectobject.phy_position_y = mouse_y;
            }
        }else{
            //show_debug_message("error object");
        }
    
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
